<!DOCTYPE HTML>
<!--
	Twenty by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>Object-Oriented Programming</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="../assets/css/main.css" />
		<noscript><link rel="stylesheet" href="../assets/css/noscript.css" /></noscript>
	</head>
	<body class="no-sidebar is-preload">
		<div id="page-wrapper">

			<!-- Header -->
			<header id="header">
				<h1 id="logo"><a href="../index.html">Adam Cox <span>ePortfolio</span></a></h1>
				<nav id="nav">
					<ul>
						<li class="submenu">
							<a href="#">Menu</a>
							<ul>
								<li><a href="about-me.html">About Me</a></li>
								<li><a href="../launch-module.html">Launch Module</a></li>
								<li><a href="../module-1/Launching-into-Computer-Science.html">Launching into Computer Science</a></li>	
								<li><a href="../module-2/Object-OrientedInformationSystems.html">Object-Oriented Information Systems</a></li>		
								<li><a href="../module-3/home.html">Secure Software Development</a></li>	
							</ul>
						</li>
					</ul>
				</nav>
			</header>

			<!-- Main -->
				<article id="main">

					<header class="special container">
						<span class="icon solid fa-laptop"></span>
						<h2 style="color:#1271EA; font-weight:400">Object-Oriented Programming</h2>
						<p>Reflecting on the Object-Oriented Programming Paradigm</p>
					</header>

					<!-- One -->
						<section class="wrapper style4 container">

							<!-- Content -->
								<div class="content">
									<section>
										<header>
											<h3 >Reflecting on the Object-Oriented Programming Paradigm</h3>
										</header>

										<p>I believe humans not only have a tendency to create order but require it in order to succeed. Arguably this need for order is exaggerated in the field of programming. From the perspective of the machine that runs your code, whether or not that code is well-ordered matters not, provided the implementations are functional and correct. From the perspective of the developers working with the code however the order, the code is in greatly impacts their ability to work with the code in the future. As such I see that the Object Orientated Paradigm was not developed for computers but humans.</p>

										<p>The Object-Oriented paradigm enforces a type of order on the code that can be written with it. The constraints placed upon the programmer using OOP do not affect the machine that runs the code, after all, all code gets converted into the same machine code eventually. In OOP the system must be composed of a number of objects, each object having data and behaviour. This is an additional constraint compared to procedural programming where the system would be composed of data and behaviour that is not 'grouped' by objects.</p>
										
										<p>One of the first things we are often told when introduced to OOP is that an object represents a 'thing in the real world'. Quickly we realize however that many of the objects in our system will have no relation to 'real' world objects. I think that developing the ability to recognize abstract concepts as objects is a crucial progression in learning OOP. Once we start to realize that pretty much anything can be an object we realize our true job is to decide which models provide the most value for our system. Deciding which abstract concepts deserve their own objects and which concepts can be broken into multiple objects is at the heart of using OOP and a skill that takes a lifetime to refine.</p>
										
										<p>While humans may require order and structure, given the opportunity we will 'cut corners' for short term gain. Where some people may avoid paying taxes to the detriment of society, some programmers may use the go-to command to the detriment of their codebase. In both cases, short term gain is paid for with a longer-term degradation to the system. In the 'real' world it is only possible to make a crime illegal, not prevent the crime from occurring altogether. In programming, we can not only make 'crimes' illegal but totally prevent them from happening. When a software engineer agrees to develop a project using an OOP language they are restricting their freedom of expression for the guarantee of the level of structure.</p>
										
										<p>Creativity flourishes with constraints. It is often easier to come up with solutions to problems when a project has constraints. Likewise, the use of OOP provides a constrained way of thinking about problems. Without the use of OOP, the possibilities for structuring a project are limitless, it can be easier to develop a solution when thinking in the framework OOP provides.</p>
										
										<p>The OOP paradigm is not perfect as can be seen with the use of static/class methods. When we write a class method we are acknowledging we do not need an (instance of an) object. There are times I simply need functionality unrelated to an object in a system and in such cases having to define an object just to provide a means to add a piece of functionality can be unnecessary.</p>
										
										<p>In my opinion, encapsulation and polymorphism are the most useful properties easily provided with OOP. Encapsulating trivial details of a class allows users to think at a 'higher level of abstraction, freeing them of the burden of the classes implementation details. I said above that 'encapsulation is the most useful property easily provided with OOP' because features like encapsulation are not unique to OOP but OOP makes encapsulation very simple. As a developer who first learnt to program using OOP, I was surprised to find that many aspects that OOP brags about were not in fact new. Encapsulation, Abstraction and even Inheritance are/were all possible in C. OOP languages such as C# simply provided a much more convenient method to achieve them.</p>
										
										<p>I think that Inheritance is a dangerous tool and composition is oftentimes a better method of code re-use. Inheritance should be used only to describe a has-a relationship. I think Inheritance should primarily be used to enable polymorphic function calls (which makes code more extendable). Being able to call functions Polymophicaly enables the use of the Dependency injection pattern that can help, reduce code coupling and increase code testability (by using a 'mock' object that conforms to the correct interface). Inheritance introduces very strong coupling in the system where the use of composition can produce less coupled systems.</p>
										
										<p>Reflecting on OOP I think it's interesting how broad an umbrella the category is. Developing using Python can be a vastly different experience compared to using C++. This is because whether a language is OOP is only one of its characteristics. Programming languages can also be Statically Typed, Dynamically Typed, Single or Multi-Threaded, Garbage collected or require manual memory management.</p>

									</section>
								</div>

						</section>					
				</article>

			<!-- Footer -->
				<footer id="footer">

					<ul class="copyright">
						<li>&copy; Untitled</li><li>Design: <a href="http://html5up.net">HTML5 UP</a></li>
					</ul>

				</footer>

		</div>

		<!-- Scripts -->
		<script src="../assets/js/jquery.min.js"></script>
		<script src="../assets/js/jquery.dropotron.min.js"></script>
		<script src="../assets/js/jquery.scrolly.min.js"></script>
		<script src="../assets/js/jquery.scrollgress.min.js"></script>
		<script src="../assets/js/jquery.scrollex.min.js"></script>
		<script src="../assets/js/browser.min.js"></script>
		<script src="../assets/js/breakpoints.min.js"></script>
		<script src="../assets/js/util.js"></script>
		<script src="../assets/js/main.js"></script>

	</body>
</html>